<!DOCTYPE html>
<html lang="ja">
<link rel="icon" href="https://storage2.me-qr.com/image/2025/Aug/15/4c1e0d74-5486-4afe-bb5a-aaa1e9b7861d.png">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÁµµÊñáÂ≠ó„ÅÆ„Ç¢„Çπ„É¨„ÉÅ„ÉÉ„ÇØ</title>
    <style>
        /* Êó•Êú¨Ë™û„Å®Ëã±Ë™û„ÅÆ„Éï„Ç©„É≥„Éà„ÇíË™≠„ÅøËæº„Åø */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=DotGothic16&display=swap');
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #e0f2f1;
            /* Êó•Êú¨Ë™û„ÅØDotGothic16„ÄÅËã±Ë™û„ÅØPress Start 2P„Çí‰ΩøÁî® */
            font-family: 'DotGothic16', 'Press Start 2P', cursive;
            color: #333;
            overflow: hidden;
            flex-direction: column;
            gap: 20px;
        }

        h3 {
            font-size: clamp(1.5rem, 5vw, 3rem);
            text-align: center;
            text-shadow: 2px 2px 0px #fff;
            margin: 0;
        }

        canvas {
            background-color: #a0e6ff; /* Sky background color */
            border: 5px solid #26a69a;
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            touch-action: none; /* Disable default touch actions to prevent unintended scrolling */
            width: 90vw;
            max-width: 800px;
            height: 45vw;
            max-height: 400px;
            aspect-ratio: 2 / 1;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px 40px;
            border: 3px solid #26a69a;
            border-radius: 10px;
            text-align: center;
            font-size: clamp(1rem, 4vw, 2rem);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 10;
        }

        /* „Çπ„Ç≥„Ç¢Ë°®Á§∫„ÅØcanvasÂÜÖ„Å´ÁßªÂãï„Åó„Åü„Åü„ÇÅÂâäÈô§ */
        
        @media (max-width: 600px) {
            h3 {
                font-size: clamp(1.2rem, 6vw, 2.5rem);
            }
        }
    </style>
</head>
<body>

    <h3>ÁµµÊñáÂ≠ó„ÅÆ„Ç¢„Çπ„É¨„ÉÅ„ÉÉ„ÇØ</h3>
    <canvas id="gameCanvas"></canvas>
    <div class="message-box" id="messageBox">
        <div id="messageText"></div>
        <br>
        <span style="font-size: 0.5em;">‰∏äÁü¢Âç∞„Ç≠„Éº„ÇíÊäº‰∏ã„Åæ„Åü„ÅØÁîªÈù¢„Çí„Çø„ÉÉ„Éó<br></span>
    </div>

    <script>
        window.onload = function() {
            // Get game canvas and context
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            
            // Dynamically set canvas size for responsiveness
            const setCanvasSize = () => {
                const ratio = window.devicePixelRatio || 1;
                const displayWidth  = canvas.clientWidth;
                const displayHeight = canvas.clientHeight;
                canvas.width = displayWidth * ratio;
                canvas.height = displayHeight * ratio;
                ctx.scale(ratio, ratio);
            };
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);

            // Audio variables
            let audioContext;
            let isAudioReady = false;

            // Utility function to play a sound
            const playSound = (frequency, type, duration) => {
                if (!isAudioReady) return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = type;
                oscillator.frequency.value = frequency;
                
                // Connect oscillator to gain and gain to destination
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Reduce volume quickly to create a 'click' effect
                gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            };

            // Game state variables
            let scrollOffset = 0; // The total distance the world has scrolled
            let score = 0;
            let isGameOver = true;
            let obstacles = [];
            let coins = [];
            let enemies = [];
            let goal;
            let keys = {}; // Object to track pressed keys

            // Player settings
            const player = {
                x: 150, // Player's horizontal position is fixed on the screen initially
                y: 0,
                width: 30,
                height: 50,
                isGrounded: true, // Start grounded
                isJumping: false,
                jumpCounter: 0,
                maxJumpFrames: 25, // The number of frames for the ascending part of the jump
                jumpSpeed: 5,
                moveSpeed: 3, // Player speed reduced from 5 to 3
                direction: 1, // 1 = right, -1 = left
                draw() {
                    // Draw player at a fixed position on the screen, relative to scrollOffset
                    const drawX = 150; 
                    const drawY = canvas.height / (window.devicePixelRatio || 1) - 50 - this.height - this.y;
                    const centerX = drawX + this.width / 2;
                    const centerY = drawY + this.height / 2;

                    ctx.save();
                    ctx.font = '50px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Flip the emoji based on the player's direction
                    if (this.direction === 1) {
                        ctx.translate(centerX, centerY);
                        ctx.scale(-1, 1);
                        ctx.fillText('üèÉ‚Äç‚ôÇÔ∏è', 0, 0);
                    } else {
                        ctx.fillText('üèÉ‚Äç‚ôÇÔ∏è', centerX, centerY);
                    }

                    ctx.restore();
                },
                update() {
                    // Update jump state based on a counter
                    if (this.isJumping) {
                        // ‰∏äÊòá„Éï„Çß„Éº„Ç∫ (Ascending phase)
                        if (this.jumpCounter < this.maxJumpFrames) {
                            this.y += this.jumpSpeed;
                            this.jumpCounter++;
                        } 
                        // ‰∏ãÈôç„Éï„Çß„Éº„Ç∫ (Descending phase)
                        else {
                            this.y -= this.jumpSpeed;
                            
                            // ÁùÄÂú∞Âà§ÂÆö (Landing check)
                            if (this.y <= 0) {
                                this.y = 0;
                                this.isGrounded = true;
                                this.isJumping = false;
                                this.jumpCounter = 0;
                            }
                        }
                    }
                    
                    // Update player's world position
                    if (keys['ArrowRight']) {
                        this.x += this.moveSpeed;
                        this.direction = 1;
                    } else if (keys['ArrowLeft'] && this.x > 0) {
                        this.x -= this.moveSpeed;
                        this.direction = -1;
                    }

                    // The scrollOffset is now based on the player's world position
                    scrollOffset = this.x - 150;
                },
                jump() {
                    // Only allow jumping if the player is on the ground
                    if (this.isGrounded) {
                        this.isJumping = true;
                        this.isGrounded = false;
                        this.jumpCounter = 0;
                        // „Ç∏„É£„É≥„Éó„ÅÆÂäπÊûúÈü≥„ÇíËøΩÂä†
                        playSound(500, 'sine', 0.1);
                    }
                }
            };

            // Obstacle class
            class Obstacle {
                constructor(x, y, width, height) {
                    this.x = x; // World coordinate
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.emoji = 'üß±';
                }

                draw() {
                    const drawX = this.x - scrollOffset; // Draw based on world coordinate and scroll offset
                    const drawY = canvas.height / (window.devicePixelRatio || 1) - 50 - this.height;
                    
                    ctx.font = '40px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.emoji, drawX + this.width / 2, drawY + this.height / 2);
                }
            }

            // Coin class
            class Coin {
                constructor(x, y) {
                    this.x = x; // World coordinate
                    this.y = y;
                    this.width = 30;
                    this.height = 30;
                    this.collected = false;
                    this.emoji = 'ü™ô';
                }

                draw() {
                    if (!this.collected) {
                        const drawX = this.x - scrollOffset;
                        const drawY = canvas.height / (window.devicePixelRatio || 1) - 50 - this.y;
                        
                        ctx.font = '30px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.emoji, drawX + this.width / 2, drawY + this.height / 2);
                    }
                }
            }

            // Enemy class
            class Enemy {
                constructor(x, y, width, height, emoji, speed, minX, maxX) {
                    this.x = x; // World coordinate
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.emoji = emoji;
                    this.speed = speed || 0;
                    this.direction = 1;
                    this.minX = minX; // World coordinate
                    this.maxX = maxX; // World coordinate
                }

                draw() {
                    const drawX = this.x - scrollOffset;
                    const drawY = canvas.height / (window.devicePixelRatio || 1) - 50 - this.height;
                    const centerX = drawX + this.width / 2;
                    const centerY = drawY + this.height / 2;
                    
                    ctx.save();
                    ctx.font = '40px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Flip the emoji for moving enemies
                    if (this.speed > 0 && this.direction === -1) {
                        ctx.translate(centerX, centerY);
                        ctx.scale(-1, 1);
                        ctx.fillText(this.emoji, 0, 0);
                    } else {
                        ctx.fillText(this.emoji, centerX, centerY);
                    }

                    ctx.restore();
                }

                update() {
                    if (this.speed > 0) {
                        this.x += this.speed * this.direction;
                        // Check patrol range using world coordinates
                        if (this.x <= this.minX || this.x + this.width >= this.maxX) {
                            this.direction *= -1;
                        }
                    }
                }
            }

            // Goal class
            class Goal {
                constructor(x) {
                    this.x = x;
                    this.y = 0;
                    this.width = 60;
                    this.height = 100;
                    this.emoji = 'üèÅ';
                }

                draw() {
                    const drawX = this.x - scrollOffset;
                    const drawY = canvas.height / (window.devicePixelRatio || 1) - 50 - this.height;

                    ctx.font = '80px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.emoji, drawX + this.width / 2, drawY + this.height / 2);
                }
            }
            
            // „É¨„Éô„É´„Éá„Éº„ÇøÔºàÈùôÁöÑ„Å™ÈöúÂÆ≥Áâ©„ÄÅ„Ç≥„Ç§„É≥„ÄÅÊïµ„ÅÆÈÖçÁΩÆÔºâ
            const levelData = {
                obstacles: [
                    { x: 300, width: 20, height: 40 },
                    { x: 500, width: 20, height: 60 },
                    { x: 650, width: 20, height: 80 },
                    { x: 800, width: 20, height: 40 },
                    { x: 1000, width: 20, height: 50 },
                    { x: 1200, width: 20, height: 60 },
                    { x: 1400, width: 20, height: 70 },
                    { x: 1600, width: 20, height: 40 },
                    { x: 1800, width: 20, height: 50 },
                    { x: 2000, width: 20, height: 60 },
                    { x: 2400, width: 20, height: 80 },
                    { x: 2600, width: 20, height: 60 },
                    { x: 2800, width: 20, height: 50 },
                    { x: 3000, width: 20, height: 70 },
                ],
                coins: [
                    { x: 400, y: 70 },
                    { x: 750, y: 100 },
                    { x: 900, y: 50 },
                    { x: 1100, y: 80 },
                    { x: 1300, y: 120 },
                    { x: 1500, y: 70 },
                    { x: 1700, y: 90 },
                    { x: 1900, y: 60 },
                    { x: 2150, y: 100 },
                    { x: 2350, y: 80 },
                    { x: 2500, y: 110 },
                    { x: 2750, y: 60 },
                    { x: 2950, y: 90 },
                ],
                enemies: [
                    { x: 900, y: 0, width: 40, height: 40, emoji: 'üê¢' },
                    { x: 1500, y: 0, width: 40, height: 40, emoji: 'üê¢' },
                    { x: 2300, y: 0, width: 40, height: 40, emoji: 'üçÑ', speed: 1, minX: 2200, maxX: 2400 },
                    { x: 2800, y: 0, width: 40, height: 40, emoji: 'üê¢' },
                    { x: 3200, y: 0, width: 40, height: 40, emoji: 'üçÑ', speed: 1, minX: 3100, maxX: 3300 },
                ],
                goal: { x: 3400 }
            };

            // Draw game elements
            function draw() {
                ctx.clearRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));

                // Draw the ground
                ctx.fillStyle = '#b2dfdb';
                ctx.fillRect(0, canvas.height / (window.devicePixelRatio || 1) - 50, canvas.width / (window.devicePixelRatio || 1), 50);

                // Draw game elements based on scroll offset
                obstacles.forEach(obstacle => obstacle.draw());
                coins.forEach(coin => coin.draw());
                enemies.forEach(enemy => enemy.draw());
                goal.draw();

                player.draw();

                // Draw score on the canvas
                ctx.fillStyle = '#333';
                ctx.font = '20px DotGothic16';
                ctx.textAlign = 'left';
                ctx.fillText(`„Çπ„Ç≥„Ç¢: ${score}`, 20, 30);
            }

            // Update game state
            function update() {
                if (isGameOver) return;
                
                const collectedCoinsCount = coins.filter(c => c.collected).length;
                score = collectedCoinsCount;
                // „Çπ„Ç≥„Ç¢Ë°®Á§∫„ÇícanvasÂÜÖ„Å´ÁßªÂãï„Åó„Åü„Åü„ÇÅÂâäÈô§
                // scoreDisplay.textContent = `„Çπ„Ç≥„Ç¢: ${score}`;

                player.update();
                enemies.forEach(enemy => enemy.update());
                
                checkCollisions();
            }
            
            // Collision detection
            function checkCollisions() {
                // All collision checks are now done using world coordinates
                const playerRect = {
                    x: player.x,
                    y: canvas.height / (window.devicePixelRatio || 1) - 50 - player.height - player.y,
                    width: player.width,
                    height: player.height
                };

                const isColliding = (rect1, rect2) => {
                    return rect1.x < rect2.x + rect2.width &&
                           rect1.x + rect1.width > rect2.x &&
                           rect1.y < rect2.y + rect2.height &&
                           rect1.y + rect1.height > rect2.y;
                };

                // Check for obstacle collisions
                obstacles.forEach(obstacle => {
                    const obstacleRect = {
                        x: obstacle.x,
                        y: canvas.height / (window.devicePixelRatio || 1) - 50 - obstacle.height,
                        width: obstacle.width,
                        height: obstacle.height
                    };
                    if (isColliding(playerRect, obstacleRect)) {
                        gameOver();
                    }
                });

                // Check for enemy collisions with player and with obstacles
                enemies.forEach(enemy => {
                    const enemyRect = {
                        x: enemy.x,
                        y: canvas.height / (window.devicePixelRatio || 1) - 50 - enemy.height,
                        width: enemy.width,
                        height: enemy.height
                    };
                    
                    if (isColliding(playerRect, enemyRect)) {
                        gameOver();
                    }
                    
                    if (enemy.speed > 0) {
                        obstacles.forEach(obstacle => {
                            const obstacleRect = {
                                x: obstacle.x,
                                y: canvas.height / (window.devicePixelRatio || 1) - 50 - obstacle.height,
                                width: obstacle.width,
                                height: obstacle.height
                            };
                            if (isColliding(enemyRect, obstacleRect)) {
                                enemy.direction *= -1;
                            }
                        });
                    }
                });

                // Check for coin collection
                coins.forEach(coin => {
                    if (!coin.collected) {
                        const coinRect = {
                            x: coin.x,
                            y: canvas.height / (window.devicePixelRatio || 1) - 50 - coin.y - coin.height / 2,
                            width: coin.width,
                            height: coin.height
                        };

                        if (isColliding(playerRect, coinRect)) {
                            coin.collected = true;
                            playSound(800, 'square', 0.08);
                        }
                    }
                });

                // Check for goal collision
                const goalRect = {
                    x: goal.x,
                    y: canvas.height / (window.devicePixelRatio || 1) - 50 - goal.height,
                    width: goal.width,
                    height: goal.height
                };

                if (isColliding(playerRect, goalRect)) {
                    gameClear();
                }

                // Check if player falls off the screen
                if (player.y < -100) { 
                    gameOver();
                }
            }

            // Game over handler
            function gameOver() {
                isGameOver = true;
                messageText.textContent = 'Game Over!';
                messageBox.style.display = 'block';
                playSound(150, 'sawtooth', 0.5);
            }

            // Game clear handler
            function gameClear() {
                isGameOver = true;
                messageText.textContent = 'Game Clear!';
                messageBox.style.display = 'block';
                playSound(880, 'triangle', 0.5);
            }

            // Game reset
            function resetGame() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                isAudioReady = true;

                score = 0;
                scrollOffset = 0;
                isGameOver = false;
                player.x = 150; // Reset player's world position
                player.y = 0;
                player.isGrounded = true;
                messageBox.style.display = 'none';

                obstacles = levelData.obstacles.map(data => new Obstacle(data.x, data.y, data.width, data.height));
                coins = levelData.coins.map(data => new Coin(data.x, data.y));
                enemies = levelData.enemies.map(data => new Enemy(data.x, data.y, data.width, data.height, data.emoji, data.speed, data.minX, data.maxX));
                goal = new Goal(levelData.goal.x);
                
                gameLoop();
            }

            // Game loop
            let animationId;
            function gameLoop() {
                update();
                draw();
                if (!isGameOver) {
                    animationId = requestAnimationFrame(gameLoop);
                }
            }

            const handleJump = () => {
                if (isGameOver) {
                    resetGame();
                } else {
                    player.jump();
                }
            };
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'ArrowUp') {
                    e.preventDefault();
                    handleJump();
                }
            });
            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            canvas.addEventListener('click', (e) => {
                if (isGameOver) {
                    resetGame();
                } else {
                    player.jump();
                }
            });
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (isGameOver) {
                    resetGame();
                } else {
                    player.jump();
                }
            });

            resetGame();
        };
    </script>
</body>
</html>
